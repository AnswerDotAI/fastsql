[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Source",
    "section": "",
    "text": "source",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#database-and-dbtable",
    "href": "core.html#database-and-dbtable",
    "title": "Source",
    "section": "Database and DBTable",
    "text": "Database and DBTable\nWe create a Database class and a DBTable class (which is returned by Database.create), using sqlalchemy v2. These classes will allow us to directly work with dataclasses such as these:\n\nconn_str = _db_str(\":memory:\"); conn_str\n\n'sqlite:///:memory:'\n\n\n\nsource\n\nDatabase\n\ndef Database(\n    conn_str, engine_kws:NoneType=None\n):\n\nA connection to a SQLAlchemy database\n\ndb = Database(conn_str); db\n\nDatabase(sqlite:///:memory:)\n\n\n\n# create a test table\ndb.execute(sa.text('create table test (id integer primary key, name text, age integer)'))\ndb.meta.reflect(bind=db.engine)\n\n\ndb.meta.tables\n\nFacadeDict({'test': Table('test', MetaData(), Column('id', INTEGER(), table=&lt;test&gt;, primary_key=True), Column('name', TEXT(), table=&lt;test&gt;), Column('age', INTEGER(), table=&lt;test&gt;), schema=None)})\n\n\n\nsource\n\n\nDatabase.q\n\ndef q(\n    sql:str, params:VAR_KEYWORD\n):\n\nQuery database with raw SQL and optional parameters. Returns list of dicts.\n\n# add some data to it\ndb.q('insert into test (name, age) values (:name, :age)', name='Alice', age=30)\ndb.q('insert into test (name, age) values (:name, :age)', name='Bob', age=25)\n\n[]\n\n\n\ndb.q('select * from test')\n\n[{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 2, 'name': 'Bob', 'age': 25}]\n\n\n\n# update Alice's age to 32\ndb.q('update test set age = :age where name = :name', age=32, name='Alice')\n\n[]\n\n\n\ndb.q('select * from test')\n\n[{'id': 1, 'name': 'Alice', 'age': 32}, {'id': 2, 'name': 'Bob', 'age': 25}]\n\n\n\nsource\n\n\nDBTable\n\ndef DBTable(\n    table:Table, db:Database, cls, _exists:NoneType=None\n):\n\nA connection to a SQLAlchemy table, created if needed\n\n# create a DBTable with the Test table\ntbl = DBTable(db.meta.tables['test'], db, None)\ntbl\n\n&lt;Table test (id, name, age)&gt;\n\n\n\nsource\n\n\nDBTable.t\n\ndef t(\n    \n):\n\n\ntbl.t\n\n(Table('test', MetaData(), Column('id', INTEGER(), table=&lt;test&gt;, primary_key=True), Column('name', TEXT(), table=&lt;test&gt;), Column('age', INTEGER(), table=&lt;test&gt;), schema=None),\n &lt;sqlalchemy.sql.base.ReadOnlyColumnCollection&gt;)\n\n\n\nsource\n\n\nDBTable.pks\n\ndef pks(\n    \n):\n\n\ntbl.pks\n\n(Column('id', INTEGER(), table=&lt;test&gt;, primary_key=True),)\n\n\n\nsource\n\n\nDBTable.schema\n\ndef schema(\n    \n):\n\n\nprint(tbl.schema)\n\nCREATE TABLE test (\n    id INTEGER, \n    name TEXT, \n    age INTEGER, \n    PRIMARY KEY (id)\n)\n\n\n\nsource\n\n\nDatabase.table\n\ndef table(\n    nm:str, cls:NoneType=None\n):\n\n\ndb.table('test')\n\n&lt;Table test (id, name, age)&gt;\n\n\n\nsource\n\n\nDatabase.__getitem__\n\ndef __getitem__(\n    nm:str\n):\n\n\ndb['test']\n\n&lt;Table test (id, name, age)&gt;\n\n\n\nsource\n\n\ndatabase\n\ndef database(\n    path, wal:bool=True, kwargs:VAR_KEYWORD\n)-&gt;Any:\n\nCreate a Database from a path or connection string\n\ndb = database(\"sqlite:///:memory:\"); db\n\nDatabase(sqlite:///:memory:)\n\n\n\nsource\n\n\ncreate_mod\n\ndef create_mod(\n    db, mod_fn, with_views:bool=False, store:bool=True, suf:str=''\n):\n\nCreate module for dataclasses for db\n\nsource\n\n\nall_dcs\n\ndef all_dcs(\n    db, with_views:bool=False, store:bool=True, suf:str=''\n):\n\ndataclasses for all objects in db\n\nsource\n\n\nDatabase.get_tables\n\ndef get_tables(\n    glb\n):\n\nAdd objects for all table objects to namespace glb\n\nsource\n\n\nDatabase.set_classes\n\ndef set_classes(\n    glb\n):\n\nAdd set all table dataclasses using types in namespace glb\n\nsource\n\n\nDatabase.link_dcs\n\ndef link_dcs(\n    mod\n):\n\nSet the internal dataclass type links for tables using mod (created via create_mod)\n\nsource\n\n\nDBTable.lookup\n\ndef lookup(\n    lookup_values:Dict, extra_values:Optional=None, pk:str | None='id', kwargs:VAR_KEYWORD\n):\n\n\nsource\n\n\nDBTable.upsert\n\ndef upsert(\n    record:Any=None, pk:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    foreign_keys:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    column_order:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    not_null:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    defaults:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id_columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    alter:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    extracts:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    conversions:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    strict:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;, kwargs:VAR_KEYWORD\n)-&gt;Any:",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#crud-operations",
    "href": "core.html#crud-operations",
    "title": "Source",
    "section": "CRUD Operations",
    "text": "CRUD Operations\n\nsource\n\nget_typ\n\ndef get_typ(\n    t\n):\n\nGet the underlying type.\n\nget_typ(int|None), get_typ(list[str])\n\n(int, str)\n\n\n\n_sa_type(int)\n\nsqlalchemy.sql.sqltypes.Integer\n\n\n\n_column('age', int)\n\nColumn('age', Integer(), table=None)\n\n\n\nsource\n\n\nDatabase.create\n\ndef create(\n    cls:type, pk:str='id', name:str | None=None, foreign_keys:NoneType=None, defaults:NoneType=None,\n    column_order:NoneType=None, not_null:NoneType=None, hash_id:NoneType=None, hash_id_columns:NoneType=None,\n    extracts:NoneType=None, if_not_exists:bool=False, replace:bool=False, ignore:bool=True, transform:bool=False,\n    strict:bool=False, constraints:NoneType=None\n):\n\nGet a table object, creating in DB if needed\n\nclass User: name:str; pwd:str\nclass Todo: title:str; name:str; id:int; done:bool=False; details:str=''\nclass Student: id:int; grad_year:int; name:str\n\n\nusers = db.create(User, pk='name')\ntodos = db.create(Todo, pk='id')\nstudents = db.create(Student, pk=('id', 'grad_year'))\n\n\nsource\n\n\nDatabase.view_names\n\ndef view_names(\n    \n):\n\n\nsource\n\n\nDatabase.table_names\n\ndef table_names(\n    \n):\n\n\ndb.table_names()\n\n['student', 'todo', 'user']\n\n\n\nsource\n\n\nDatabase.schema\n\ndef schema(\n    \n):\n\nShow all tables and columns\n\nprint(db.schema())\n\nTable: student\n  * id: INTEGER\n  * grad_year: INTEGER\n  - name: VARCHAR\nTable: todo\n  - title: VARCHAR\n  - name: VARCHAR\n  * id: INTEGER\n  - done: BOOLEAN\n  - details: VARCHAR\nTable: user\n  * name: VARCHAR\n  - pwd: VARCHAR\n\n\n\n\nsource\n\n\nDatabase.t\n\ndef t(\n    \n):\n\nBy returning a _TablesGetter we get a repr and auto-complete that shows all tables in the DB.\n\ndb.t\n\nstudent, todo, user\n\n\n\nsource\n\n\nDBTable.c\n\ndef c(\n    \n):\n\nSimilarly, we return _ColsGetter for a table’s columns\n\nusers.c\n\nname, pwd\n\n\n\nsource\n\n\nDBTable.create\n\ndef create(\n    columns:Dict=None, pk:Any=None, foreign_keys:NoneType=None, column_order:Optional=None, not_null:Optional=None,\n    defaults:Optional=None, hash_id:str | None=None, hash_id_columns:Optional=None, extracts:Union=None,\n    if_not_exists:bool=False, replace:bool=False, ignore:bool=False, transform:bool=False, strict:bool=False,\n    kwargs:VAR_KEYWORD\n):\n\nCreate table from column definitions passed as kwargs or columns dict\n\nsource\n\n\nDBTable.exists\n\ndef exists(\n    \n):\n\nCheck if this table exists in the DB\n\nusers.exists()\n\nTrue\n\n\n\nu0 = User('jph','foo')\nu1 = User('rlt','bar')\nt0 = Todo('do it', 'jph')\nt1 = Todo('get it done', 'rlt')\n\n\nsource\n\n\nDBTable.insert\n\ndef insert(\n    record:Dict=None, pk:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    foreign_keys:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    column_order:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    not_null:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    defaults:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id_columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    alter:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    ignore:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    replace:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    extracts:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    conversions:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    strict:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;, kwargs:VAR_KEYWORD\n)-&gt;Any:\n\nInsert an object into this table, and return it\n\nt = todos.insert(t0)\nassert t.id\nt\n\nTodo(title='do it', name='jph', id=1, done=False, details='')\n\n\n\nu = users.insert(u0)\nassert u.name=='jph'\nusers.insert(u1)\nu\n\nUser(name='jph', pwd='foo')\n\n\n\ntodos.insert(t1)\n\nTodo(title='get it done', name='rlt', id=2, done=False, details='')\n\n\n\nsource\n\n\nDBTable.insert_all\n\ndef insert_all(\n    records:Optional=None, pk:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    foreign_keys:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    column_order:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    not_null:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    defaults:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    batch_size:Default=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    hash_id_columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    alter:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    ignore:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    replace:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;, truncate:bool=False,\n    extracts:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    conversions:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    columns:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;,\n    strict:Union=&lt;__main__.Default object at 0x7fe1bb4866f0&gt;, upsert:bool=False, analyze:bool=False,\n    xtra:dict | None=None, kwargs:VAR_KEYWORD\n)-&gt;DBTable:\n\n\ntodos.insert_all([t0,t1])\n\n&lt;Table todo (title, name, id, done, details)&gt;\n\n\n\nsource\n\n\nDBTable.count_where\n\ndef count_where(\n    where:Optional=None, where_args:Union=None, kw:VAR_KEYWORD\n)-&gt;int:\n\n\nsource\n\n\nDBTable.count\n\ndef count(\n    \n):\n\n\nsource\n\n\nDBTable.__len__\n\ndef __len__(\n    \n):\n\n\ntodos.count, len(todos)\n\n(4, 4)\n\n\n\nsource\n\n\nDBTable.rows_where\n\ndef rows_where(\n    where:Optional=None, where_args:Union=None, order_by:Optional=None, select:str='*', limit:Optional=None,\n    offset:Optional=None, xtra:dict | None=None, kw:VAR_KEYWORD\n)-&gt;Generator:\n\n\nsource\n\n\nDBTable.pks_and_rows_where\n\ndef pks_and_rows_where(\n    where:Optional=None, where_args:Union=None, order_by:Optional=None, select:str='*', limit:Optional=None,\n    offset:Optional=None, xtra:dict | None=None, kw:VAR_KEYWORD\n)-&gt;Generator:\n\n\nsource\n\n\nDBTable.rows\n\ndef rows(\n    \n):\n\n\nsource\n\n\nDBTable.__call__\n\ndef __call__(\n    where:str | None=None, # SQL where fragment to use, for example `id &gt; ?`\n    where_args:Union=None, # Parameters to use with `where`; iterable for `id&gt;?`, or dict for `id&gt;:id`\n    order_by:str | None=None, # Column or fragment of SQL to order by\n    limit:int | None=None, # Number of rows to limit to\n    offset:int | None=None, # SQL offset\n    select:str='*', # Comma-separated list of columns to select\n    with_pk:bool=False, # Return tuple of (pk,row)?\n    as_cls:bool=True, # Convert returned dict to stored dataclass?\n    xtra:dict | None=None, # Extra constraints\n    kw:VAR_KEYWORD\n):\n\nResult of select query on the table. Returns list of returned objects.\n\nassert users()==[u0,u1]\nusers()\n\n[User(name='jph', pwd='foo'), User(name='rlt', pwd='bar')]\n\n\n\nr = users(where=\"pwd LIKE :pwd\", pwd=\"b%\")\nassert r==[u1]\nr\n\n[User(name='rlt', pwd='bar')]\n\n\n\nusers.xtra(name='rlt')\nusers(order_by='name')\n\n[User(name='rlt', pwd='bar')]\n\n\n\nusers(where='name=\"rlt\"')\n\n[User(name='rlt', pwd='bar')]\n\n\n\nusers(where='name=\"jph\"')\n\n[]\n\n\n\nassert len(todos())==4\ntodos()\n\n[Todo(title='do it', name='jph', id=1, done=False, details=''),\n Todo(title='get it done', name='rlt', id=2, done=False, details=''),\n Todo(title='do it', name='jph', id=3, done=False, details=''),\n Todo(title='get it done', name='rlt', id=4, done=False, details='')]\n\n\n\nsource\n\n\nDatabase.create_view\n\ndef create_view(\n    name:str, sql:str, ignore:bool=False, replace:bool=False\n):\n\nCreate a view with the given name and SQL query\n\n# Create a view showing only incomplete todos\ndb.create_view('pending_todos', 'SELECT * FROM todo WHERE done = 0')\n\n\nsource\n\n\nDatabase.v\n\ndef v(\n    \n):\n\n\ndb.v.pending_todos()\n\n[{'title': 'do it', 'name': 'jph', 'id': 1, 'done': False, 'details': ''},\n {'title': 'get it done',\n  'name': 'rlt',\n  'id': 2,\n  'done': False,\n  'details': ''},\n {'title': 'do it', 'name': 'jph', 'id': 3, 'done': False, 'details': ''},\n {'title': 'get it done',\n  'name': 'rlt',\n  'id': 4,\n  'done': False,\n  'details': ''}]\n\n\n\nsource\n\n\nMissingPrimaryKey\n\ndef MissingPrimaryKey(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nNotFoundError\n\ndef NotFoundError(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nDBTable.__getitem__\n\ndef __getitem__(\n    key\n):\n\n\nsource\n\n\nDBTable.get\n\ndef get(\n    pk_values, as_cls:bool=True, xtra:dict | None=None, default:Any=UNSET\n)-&gt;Any:\n\nGet item with PK key\n\nusers.xtra(name='jph')\nassert users['jph']==u0\nusers['jph']\n\nUser(name='jph', pwd='foo')\n\n\n\nusers.xtra(name='rlt')\ntest_fail(lambda: users['jph']==u0)\n\n\nsource\n\n\nDBTable.selectone\n\ndef selectone(\n    where:str | None=None, where_args:Union=None, select:str='*', as_cls:bool=True, xtra:dict | None=None,\n    kwargs:VAR_KEYWORD\n):\n\n\nusers.xtra()  # clear xtra\ntest_eq(users.selectone('name=?', ['jph']).name, 'jph')\n\n\nsource\n\n\nDBTable.update\n\ndef update(\n    updates:dict | None=None, pk_values:list | tuple | str | int | float | None=None, alter:bool=False,\n    conversions:dict | None=None, xtra:dict | None=None, kwargs:VAR_KEYWORD\n)-&gt;Any:\n\n\nusers.xtra(name='jph')\nu.pwd = 'new'\nusers.update(u)\nusers.xtra()\nusers()\n\n[User(name='jph', pwd='new'), User(name='rlt', pwd='bar')]\n\n\n\nusers.xtra(name='rlt')\nu.pwd = 'foo'\nusers.update(u)\nusers.xtra()\ntest_eq(users['jph'].pwd, 'new')\n\n\nsource\n\n\nDBTable.update_where\n\ndef update_where(\n    updates:dict, where:str | None=None, where_args:Union=None, xtra:dict | None=None, kw:VAR_KEYWORD\n)-&gt;list:\n\nUpdate rows matching where with updates. Returns updated rows.\n\nsource\n\n\nDBTable.update_where\n\ndef update_where(\n    updates:dict, where:str | None=None, where_args:Union=None, xtra:dict | None=None, kw:VAR_KEYWORD\n)-&gt;list:\n\nUpdate rows matching where with updates. Returns updated rows.\n\ntodos.update_where({'done': True}, where='name = :name', name='jph')\n\n[Todo(title='do it', name='jph', id=1, done=True, details=''),\n Todo(title='do it', name='jph', id=3, done=True, details='')]\n\n\n\nsource\n\n\nDBTable.delete\n\ndef delete(\n    key\n):\n\nDelete item with PK key and return the deleted object\n\nassert users.delete('jph')\ntest_fail(lambda: users['jph'])\n\n\nsource\n\n\nDBTable.delete_where\n\ndef delete_where(\n    where:Optional=None, where_args:Union=None, xtra:dict | None=None, kw:VAR_KEYWORD\n):\n\n\ntodos.delete_where(\"name = ?\", [\"jph\"])\n\n[Todo(title='do it', name='jph', id=1, done=True, details=''),\n Todo(title='do it', name='jph', id=3, done=True, details='')]\n\n\n\ntodos('name=?', ['jph'])\n\n[]\n\n\n\nsource\n\n\nDBTable.__contains__\n\ndef __contains__(\n    pk_values:Union\n)-&gt;bool: # A single value, or a tuple of values for tables that have a compound primary key\n\nIs the item with the specified primary key value in this table?\nDemonstration with single field primary key:\n\nassert not 'jph' in users\nassert 'rlt' in users\n\nFor compound primary keys, lets whether a student is in the students table or not.\n\nstudents.insert(Student(1, 2021, 'jph'))\n\nStudent(id=1, grad_year=2021, name='jph')\n\n\n\nassert (1,2021) in students\nassert (1,2030) not in students\n\n\nsource\n\n\nDBTable.drop\n\ndef drop(\n    ignore:bool=False\n):\n\nDrop this table from the database\n\nstudents.drop()\nassert 'student' not in db.t",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#migrations",
    "href": "core.html#migrations",
    "title": "Source",
    "section": "Migrations",
    "text": "Migrations\n\ndb.t\n\ntodo, user\n\n\n\nsource\n\nMeta\n\ndef Meta(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nInitialize self. See help(type(self)) for accurate signature.\n\ndb._add_meta(); db.t\n\n_meta, todo, user\n\n\n\nprint(db['_meta'].schema)\n\nCREATE TABLE _meta (\n    id INTEGER, \n    version INTEGER, \n    PRIMARY KEY (id), \n    CHECK (id = 1)\n)\n\n\n\ndb['_meta']()\n\n[Meta(id=1, version=0)]\n\n\n\ndb.version\n\n0\n\n\n\ndb.version = 1; db.version\n\n1\n\n\n\nmdir = Path('./migrations')\n_get_migrations(mdir)\n\n[(1, Path('migrations/1-add_priority_and_due_date_to_todo.sql'))]\n\n\n\nsource\n\n\nDatabase.migrate\n\ndef migrate(\n    mdir\n):\n\n\ndb.version = 0\n\n\ndb.migrate(mdir)\ntest_eq(db.version, 1)\nassert 'priority' in db.t.todo.c\nassert 'due_date' in db.t.todo.c\n\nApplied migration 1: 1-add_priority_and_due_date_to_todo.sql\n\n\n\ndb.t.todo()\n\n[Todo(title='get it done', name='rlt', id=2, done=False, details='', priority=0, due_date=None),\n Todo(title='get it done', name='rlt', id=4, done=False, details='', priority=0, due_date=None)]",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#sqlalchemy-helpers",
    "href": "core.html#sqlalchemy-helpers",
    "title": "Source",
    "section": "SQLAlchemy helpers",
    "text": "SQLAlchemy helpers\n\nsource\n\nReadOnlyColumnCollection.__dir__\n\ndef __dir__(\n    \n):\n\nDefault dir() implementation.\n\nsource\n\n\nMetaData.__dir__\n\ndef __dir__(\n    \n):\n\nDefault dir() implementation.\n\ndbm = db.meta\n\n\n' '.join(dbm.tables)\n\n'_meta todo user'\n\n\n\nt = dbm.todo\n\n\nlist(t.c)\n\n[Column('title', VARCHAR(), table=&lt;todo&gt;),\n Column('name', VARCHAR(), table=&lt;todo&gt;),\n Column('id', INTEGER(), table=&lt;todo&gt;, primary_key=True),\n Column('done', BOOLEAN(), table=&lt;todo&gt;),\n Column('details', VARCHAR(), table=&lt;todo&gt;),\n Column('priority', INTEGER(), table=&lt;todo&gt;, server_default=DefaultClause(&lt;sqlalchemy.sql.elements.TextClause object&gt;, for_update=False)),\n Column('due_date', TEXT(), table=&lt;todo&gt;)]\n\n\n\nfrom sqlalchemy.exc import ResourceClosedError\n\n\nsource\n\n\nMetaData.sql\n\ndef sql(\n    statement, args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nExecute statement string and return DataFrame of results (if any)\n\nsource\n\n\nConnection.sql\n\ndef sql(\n    statement, nm:str='Row', args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nExecute statement string and return results (if any)\n\nsource\n\n\nCursorResult.tuples\n\ndef tuples(\n    nm:str='Row'\n):\n\nGet all results as named tuples\n\n# dbm.sql('delete from todo')\n# db.conn.commit()\n\n\nrs = dbm.sql('select * from user')\nrs[0]\n\nRow(name='rlt', pwd='foo')\n\n\n\nsource\n\n\nTable.get\n\ndef get(\n    where:NoneType=None, limit:NoneType=None\n):\n\nSelect from table, optionally limited by where and limit clauses\n\nt.get(t.c.title.startswith('d'), limit=5)\n\n[]\n\n\nThis is the query that will run behind the scenes:\n\nprint(t.select().where(t.c.title.startswith('d')).limit(5))\n\nSELECT todo.title, todo.name, todo.id, todo.done, todo.details, todo.priority, todo.due_date \nFROM todo \nWHERE (todo.title LIKE :title_1 || '%')\n LIMIT :param_1\n\n\n\nsource\n\n\nMetaData.close\n\ndef close(\n    \n):\n\nClose the connection\n\ndbm.close()",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Release notes",
    "section": "",
    "text": "add engine kwargs (#28), thanks to @comhar\n\n\n\n\n\n\n\n\nadd support for migrations with multiple statements (#26), thanks to @comhar\n\n\n\n\n\n\n\n\nAlign fastsql core with fastlite-style APIs (#23), thanks to @ncoop57\n\n\n\n\n\nAdd fastmigrate system (#24), thanks to @ncoop57\nadd markdown to doc output (#20)\n\n\n\n\n\n\n\n\nUse new fastcore UNSET as asdict (#18)\n\n\n\n\n\n\n\n\nSupport dict and kwarg update args (#14)\n\n\n\n\n\n\n\n\nxtra support in insert (#10)\n\n\n\n\n\nsquare brackets not accepted by all dbs (#11)\n\n\n\n\n\n\nInit release of v2, supporting the MiniDataAPI spec"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "Release notes",
    "section": "",
    "text": "add engine kwargs (#28), thanks to @comhar"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "Release notes",
    "section": "",
    "text": "add support for migrations with multiple statements (#26), thanks to @comhar"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "Release notes",
    "section": "",
    "text": "Align fastsql core with fastlite-style APIs (#23), thanks to @ncoop57\n\n\n\n\n\nAdd fastmigrate system (#24), thanks to @ncoop57\nadd markdown to doc output (#20)"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "Release notes",
    "section": "",
    "text": "Use new fastcore UNSET as asdict (#18)"
  },
  {
    "objectID": "CHANGELOG.html#section-4",
    "href": "CHANGELOG.html#section-4",
    "title": "Release notes",
    "section": "",
    "text": "Support dict and kwarg update args (#14)"
  },
  {
    "objectID": "CHANGELOG.html#section-5",
    "href": "CHANGELOG.html#section-5",
    "title": "Release notes",
    "section": "",
    "text": "xtra support in insert (#10)\n\n\n\n\n\nsquare brackets not accepted by all dbs (#11)"
  },
  {
    "objectID": "CHANGELOG.html#section-6",
    "href": "CHANGELOG.html#section-6",
    "title": "Release notes",
    "section": "",
    "text": "Init release of v2, supporting the MiniDataAPI spec"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastsql",
    "section": "",
    "text": "pip install fastsql",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "fastsql",
    "section": "",
    "text": "pip install fastsql",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "fastsql",
    "section": "Overview",
    "text": "Overview\n\nfrom fastcore.utils import *\nfrom fastcore.net import urlsave\nfrom fastsql import *\nfrom fastsql.core import NotFoundError\n\nWe demonstrate fastsql‘s features here using the ’chinook’ sample database.\n\nurl = 'https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite'\npath = Path('chinook.sqlite')\nif not path.exists(): urlsave(url, path)\n\n\ndb = database(\"chinook.sqlite\"); db\n\nDatabase(sqlite:///chinook.sqlite)\n\n\nDatabases have a t property that lists all tables:\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\nYou can use this to grab a single table…:\n\n# artist = dt.artists\n# artist\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\n…or multiple tables at once:\n\ndt['Artist','Album','Track','Genre','MediaType']\n\n[&lt;Table Artist (ArtistId, Name)&gt;,\n &lt;Table Album (AlbumId, Title, ArtistId)&gt;,\n &lt;Table Track (TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice)&gt;,\n &lt;Table Genre (GenreId, Name)&gt;,\n &lt;Table MediaType (MediaTypeId, Name)&gt;]\n\n\nIt also provides auto-complete in Jupyter, IPython, and nearly any other interactive Python environment:\n\nYou can check if a table is in the database already:\n\n'Artist' in dt\n\nTrue\n\n\nColumn work in a similar way to tables, using the c property:\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nAuto-complete works for columns too:\n\nColumns, tables, and view stringify in a format suitable for including in SQL statements. That means you can use auto-complete in f-strings.\n\nqry = f\"select * from {artist} where {ac.Name} like 'AC/%'\"\nprint(qry)\n\nselect * from \"Artist\" where \"Artist\".\"Name\" like 'AC/%'\n\n\nYou can view the results of a select query using q:\n\ndb.q(qry)\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\nViews can be accessed through the v property:\n\nalbum = dt.Album\n\nacca_sql = f\"\"\"select {album}.*\nfrom {album} join {artist} using (ArtistId)\nwhere {ac.Name} like 'AC/%'\"\"\"\n\ndb.create_view(\"AccaDaccaAlbums\", acca_sql, replace=True)\nacca_dacca = db.q(f\"select * from {db.v.AccaDaccaAlbums}\")\nacca_dacca\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#dataclass-support",
    "href": "index.html#dataclass-support",
    "title": "fastsql",
    "section": "Dataclass support",
    "text": "Dataclass support\nA dataclass type with the names, types, and defaults of the tables is created using dataclass():\n\nalbum_dc = album.dataclass()\n\n\nalbum_dc\n\nfastsql.core.Album\n\n\nLet’s try it:\n\nalbum_obj = album_dc(**acca_dacca[0])\nalbum_obj\n\nAlbum(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)\n\n\nYou can get the definition of the dataclass using fastcore’s dataclass_src – everything is treated as nullable, in order to handle auto-generated database values:\n\nsrc = dataclass_src(album_dc)\nhl_md(src, 'python')\n\n@dataclass\nclass Album:\n    AlbumId: int | None = UNSET\n    Title: str | None = UNSET\n    ArtistId: int | None = UNSET\n\n\nBecause dataclass() is dynamic, you won’t get auto-complete in editors like vscode – it’ll only work in dynamic environments like Jupyter and IPython. For editor support, you can export the full set of dataclasses to a module, which you can then import from:\n\ncreate_mod(db, 'db_dc')\n\n\nimport sys\nsys.path.insert(0, '.')\nfrom db_dc import Track\nTrack()\n\nTrack(TrackId=UNSET, Name=UNSET, AlbumId=UNSET, MediaTypeId=UNSET, GenreId=UNSET, Composer=UNSET, Milliseconds=UNSET, Bytes=UNSET, UnitPrice=UNSET)\n\n\nIndexing into a table does a query on primary key:\n\ndt.Track[1]\n\nTrack(TrackId=1, Name='For Those About To Rock (We Salute You)', AlbumId=1, MediaTypeId=1, GenreId=1, Composer='Angus Young, Malcolm Young, Brian Johnson', Milliseconds=343719, Bytes=11170334, UnitPrice=Decimal('0.99'))\n\n\nThere’s a shortcut to select from a table – just call it as a function. If you’ve previously called dataclass(), returned iterms will be constructed using that class by default. There’s lots of params you can check out, such as limit:\n\nalbum(limit=2)\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2)]\n\n\nPass a truthy value as with_pk and you’ll get tuples of primary keys and records:\n\nalbum(with_pk=1, limit=2)\n\n[(1,\n  Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)),\n (2, Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2))]\n\n\nIndexing also uses the dataclass by default:\n\nalbum[5]\n\nAlbum(AlbumId=5, Title='Big Ones', ArtistId=3)\n\n\nIf you set xtra fields, then indexing is also filtered by those. As a result, for instance in this case, nothing is returned since album 5 is not created by artist 1:\n\nalbum.xtra(ArtistId=1)\n\ntry: album[5]\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThe same filtering is done when using the table as a callable:\n\nalbum()\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=4, Title='Let There Be Rock', ArtistId=1)]",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#core-design",
    "href": "index.html#core-design",
    "title": "fastsql",
    "section": "Core design",
    "text": "Core design\nThe following methods accept **kwargs, passing them along to the first dict param:\n\ncreate\ntransform\ntransform_sql\nupdate\ninsert\nupsert\nlookup\n\nWe can access a table that doesn’t actually exist yet:\n\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\n\ncats = dt.Cats\ncats\n\n&lt;Table Cats (does not exist yet)&gt;\n\n\nWe can use keyword arguments to now create that table:\n\ncats.create(id=int, name=str, weight=float, uid=int, pk='id')\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE \"Cats\" (\n    id INTEGER, \n    name VARCHAR, \n    weight FLOAT, \n    uid INTEGER, \n    PRIMARY KEY (id)\n)\n\n\nIt we set xtra then the additional fields are used for insert, update, and delete:\n\ncats.xtra(uid=2)\ncat = cats.insert(name='meow', weight=6)\n\nThe inserted row is returned, including the xtra ‘uid’ field.\n\ncat\n\n{'id': 1, 'name': 'meow', 'weight': 6.0, 'uid': 2}\n\n\nUsing ** in update here doesn’t actually achieve anything, since we can just pass a dict directly – it’s just to show that it works:\n\ncat['name'] = \"moo\"\ncat['uid'] = 1\ncats.update(**cat)\ncats()\n\n[{'id': 1, 'name': 'moo', 'weight': 6.0, 'uid': 2}]\n\n\nAttempts to update or insert with xtra fields are ignored.\nAn error is raised if there’s an attempt to update a record not matching xtra fields:\n\ncats.xtra(uid=1)\ntry: cats.update(**cat)\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThis all also works with dataclasses:\n\ncats.xtra(uid=2)\ncats.dataclass()\ncat = cats[1]\ncat\n\nCats(id=1, name='moo', weight=6.0, uid=2)\n\n\n\ncats.drop()\ncats\n\n&lt;Table Cats (id, name, weight, uid)&gt;\n\n\nAlternatively, you can create a table from a class. If it’s not already a dataclass, it will be converted into one. In either case, the dataclass will be created (or modified) so that None can be passed to any field (this is needed to support fields such as automatic row ids).\n\nclass Cat: id:int; name:str; weight:float; uid:int\n\n\ncats = db.create(Cat)\n\n\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE cat (\n    id INTEGER, \n    name VARCHAR, \n    weight FLOAT, \n    uid INTEGER, \n    PRIMARY KEY (id)\n)\n\n\n\ncat = Cat(name='咪咪', weight=9)\ncats.insert(cat)\n\nCat(id=1, name='咪咪', weight=9.0, uid=None)",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#manipulating-data",
    "href": "index.html#manipulating-data",
    "title": "fastsql",
    "section": "Manipulating data",
    "text": "Manipulating data\nWe try to make the following methods as flexible as possible. Wherever possible, they support Python dictionaries, dataclasses, and classes.\n\n.insert()\nCreates a record. Returns an instance of the updated record.\nInsert using a dictionary.\n\ncats.insert({'name': 'Rex', 'weight': 12.2})\n\nCat(id=2, name='Rex', weight=12.2, uid=None)\n\n\nInsert using a dataclass.\n\nCatDC = cats.dataclass()\ncats.insert(CatDC(name='Tom', weight=10.2))\n\nCat(id=3, name='Tom', weight=10.2, uid=None)\n\n\nInsert using a standard Python class\n\ncat = cats.insert(Cat(name='Jerry', weight=5.2))\n\n\n\n.update()\nUpdates a record using a Python dict, dataclass, or object, and returns an instance of the updated record.\nUpdating from a Python dict:\n\ncats.update(dict(id=cat.id, name='Jerry', weight=6.2))\n\nCat(id=4, name='Jerry', weight=6.2, uid=None)\n\n\nUpdating from a dataclass:\n\ncats.update(CatDC(id=cat.id, name='Jerry', weight=6.3))\n\nCat(id=4, name='Jerry', weight=6.3, uid=None)\n\n\nUpdating using a class:\n\ncats.update(Cat(id=cat.id, name='Jerry', weight=5.7))\n\nCat(id=4, name='Jerry', weight=5.7, uid=None)\n\n\n\n\n.delete()\nRemoving data is done by providing the primary key value of the record.\n\n# Farewell Jerry!\ncats.delete(cat.id)\n\nCat(id=4, name='Jerry', weight=5.7, uid=None)\n\n\n\n\nMulti-field primary keys\nPass a collection of strings to create a multi-field pk:\n\nclass PetFood: catid:int; food:str; qty:int\npetfoods = db.create(PetFood, pk=['catid','food'])\nprint(petfoods.schema)\n\nCREATE TABLE pet_food (\n    catid INTEGER, \n    food VARCHAR, \n    qty INTEGER, \n    PRIMARY KEY (catid, food)\n)\n\n\nYou can index into these using multiple values:\n\npf = petfoods.insert(PetFood(1, 'tuna', 2))\npetfoods[1,'tuna']\n\nPetFood(catid=1, food='tuna', qty=2)\n\n\nUpdates work in the usual way:\n\npf.qty=3\npetfoods.update(pf)\n\nPetFood(catid=1, food='tuna', qty=3)\n\n\nYou can also use upsert to update if the key exists, or insert otherwise:\n\npf.qty=1\npetfoods.upsert(pf)\npetfoods()\n\n[PetFood(catid=1, food='tuna', qty=1)]\n\n\n\npf.food='salmon'\npetfoods.upsert(pf)\npetfoods()\n\n[PetFood(catid=1, food='tuna', qty=1), PetFood(catid=1, food='salmon', qty=1)]\n\n\ndelete takes a tuple of keys:\n\npetfoods.delete((1, 'tuna'))\npetfoods()\n\n[PetFood(catid=1, food='salmon', qty=1)]",
    "crumbs": [
      "fastsql"
    ]
  },
  {
    "objectID": "index.html#migrations",
    "href": "index.html#migrations",
    "title": "fastsql",
    "section": "Migrations",
    "text": "Migrations\nFastSQL supports schema migrations to evolve your database over time. Migrations are SQL or Python files stored in a migrations directory, numbered sequentially.\nThe database tracks the current schema version in a _meta table. When you run migrations, only unapplied migrations are executed.\nLet’s create a migration to add a priority field to our cats table:\n\n# Create migrations directory\nmig_dir = Path('cat_migrations')\nmig_dir.mkdir(exist_ok=True)\n\n# Create a migration to add priority column\nmigration_sql = 'alter table cat add column color text default \"unknown\";'\n(mig_dir / '1-add_color_to_cat.sql').write_text(migration_sql)\n\n56\n\n\nCheck the current schema version (will be 0 initially):\n\nprint(f\"Current version: {db.version}\")\n\nCurrent version: 0\n\n\nRun the migration:\n\ndb.migrate('cat_migrations')\n\nApplied migration 1: 1-add_color_to_cat.sql\n\n\nThe database version is now updated, and the table structure reflects the change:\n\nprint(f\"New version: {db.version}\")\nprint(f\"\\nUpdated schema:\")\ncats = dt.cat\nhl_md(cats.schema, 'sql')\n\nNew version: 1\n\nUpdated schema:\n\n\nCREATE TABLE cat (\n    id INTEGER, \n    name VARCHAR, \n    weight FLOAT, \n    uid INTEGER, \n    color TEXT DEFAULT \"unknown\", \n    PRIMARY KEY (id)\n)\n\n\nExisting records now have the priority field with the default value, and new records can use it too:\n\ncats.insert({'name': 'Mr. Snuggles', 'weight': 8.5, 'color': 'tuxedo'})\ncats()\n\n[Cat(id=1, name='咪咪', weight=9.0, uid=None, color='unknown'),\n Cat(id=2, name='Rex', weight=12.2, uid=None, color='unknown'),\n Cat(id=3, name='Tom', weight=10.2, uid=None, color='unknown'),\n Cat(id=4, name='Mr. Snuggles', weight=8.5, uid=None, color='tuxedo')]\n\n\nIf you run migrate() again, it won’t reapply migrations that have already been applied:\n\ndb.migrate('cat_migrations')  # No output - migration already applied\n\nMigrations can also be Python scripts. Create a file like 2-update_data.py that accepts the database connection string as a command line argument to perform more complex data transformations. Python migration scripts must handle their own commits:\n# migrations/2-update_data.py\nimport sys\nfrom fastsql import database\n\nconn_str = sys.argv[1]\ndb = database(conn_str)\n\n# Perform complex data transformations\nfor cat in db.t.cat():\n    if cat.weight &gt; 10:\n        db.t.cat.update({'id': cat.id, 'priority': 1})\n\n# Python migrations must commit their own changes\ndb.conn.commit()",
    "crumbs": [
      "fastsql"
    ]
  }
]